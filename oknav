#!/bin/bash
# ==============================================================================
# OKnav - Multi-Server SSH Command Orchestrator
# ==============================================================================
#
# Execute commands across all cluster servers defined in hosts.conf.
# Servers must have (oknav) option to be included in cluster operations.
#
# Subcommands:
#   <command>    Execute command on all (oknav) servers (default)
#   install      Create/manage symlinks in /usr/local/bin from hosts.conf
#   add          Create ad-hoc host launcher (requires sudo)
#   remove       Remove ad-hoc host launcher (requires sudo)
#   list         List installed host symlinks with source and status
#
# Use -- to force command mode (bypass subcommand detection):
#   oknav -- list /tmp      Run 'list /tmp' on servers, not the list subcommand
#
# Exit codes:
#   0    Success
#   1    General error (no servers found, missing config)
#   22   Invalid option (EINVAL)
#   124  SSH connection timeout
#   125  Timeout command error
#   126  Command not found
#
# Related:
#   ok_master      - Individual server SSH handler
#   common.inc.sh  - Shared configuration and functions
#   hosts.conf     - Server definitions with (oknav) option
#
# ==============================================================================
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

SCRIPT_PATH=$(realpath -e -- "$0")
SCRIPT_DIR=${SCRIPT_PATH%/*}
SCRIPT_NAME=${SCRIPT_PATH##*/}
readonly -- SCRIPT_PATH SCRIPT_DIR SCRIPT_NAME

#shellcheck source=common.inc.sh
source "$SCRIPT_DIR"/common.inc.sh || exit 1

# ------------------------------------------------------------------------------
# Runtime Configuration
# ------------------------------------------------------------------------------
declare -i PARALLEL=0              # Execution mode: 0=sequential, 1=parallel
declare -i TIMEOUT=30              # SSH connection timeout in seconds
declare -i FORCE_EXEC=0            # Force multi-execute mode (bypass subcommands)
declare -a TEMP_FILES=()           # Temp files to clean up on exit
declare -a ok_server_excludes=()   # Servers excluded via -x option

# Working variables (declared here to satisfy strict mode)
declare -i exit_code               # Captured exit code from ssh/timeout
declare -- server                  # Current server alias being processed
declare -- pid                     # Background process ID (parallel mode)
declare -- temp_file               # Path to server output temp file
declare -- temp_file_path          # Path to temp file reference marker

# ------------------------------------------------------------------------------
# cleanup() - Remove temporary files and exit
# Args: [exit_code] - Exit code to preserve (default: 0)
# Called by: trap on SIGINT, SIGTERM, EXIT
# ------------------------------------------------------------------------------
cleanup() {
  local -i exitcode=${1:-0}
  trap - SIGINT SIGTERM EXIT  # Prevent recursion
  # Remove tracked temp files
  local -- file
  for file in "${TEMP_FILES[@]}"; do
    [[ -f "$file" ]] && rm -f "$file"
  done
  # Remove orphaned temp files (parallel subshells don't update TEMP_FILES)
  rm -f "${TEMP_DIR:-/tmp}"/"${SCRIPT_NAME:-}"_*_* 2>/dev/null || true
  rm -f "${TEMP_DIR:-/tmp}"/."${SCRIPT_NAME:-}"_*_tempfile 2>/dev/null || true
  exit "$exitcode"
}
trap 'cleanup $?' SIGINT SIGTERM EXIT

# ------------------------------------------------------------------------------
# usage() - Display help message
# ------------------------------------------------------------------------------
usage() {
  cat <<EOT
$SCRIPT_NAME $VERSION - Multi-server SSH command orchestrator

Execute commands across all servers marked with (oknav) in hosts.conf.

Usage:
  $SCRIPT_NAME [OPTIONS] <command>          Execute on all cluster servers
  $SCRIPT_NAME [OPTIONS] -- <command>       Force command mode (bypass subcommands)
  $SCRIPT_NAME install [OPTIONS]            Manage symlinks from hosts.conf
  $SCRIPT_NAME add <hostname> [alias...]    Create ad-hoc launcher
  $SCRIPT_NAME remove <alias>...            Remove launcher
  $SCRIPT_NAME list [OPTIONS]               List installed host symlinks

Options:
  -p, --parallel           Execute simultaneously on all servers
  -t, --timeout SECS       SSH connection timeout (default: $TIMEOUT)
  -x, --exclude-host HOST  Exclude host from this run (repeatable)
  -D, --debug              Show server discovery and execution details
  -V, --version            Show version
  -h, --help               Show this help

Server Discovery:
  Servers are auto-discovered from hosts.conf. Only entries with (oknav)
  option are included. Entries with (exclude) or (local-only:HOST) that
  doesn't match current hostname are filtered out.

Examples:
  $SCRIPT_NAME uptime                       Run on all servers (sequential)
  $SCRIPT_NAME -p df -h                     Run in parallel
  $SCRIPT_NAME -pt 10 uptime                Parallel with 10s timeout
  $SCRIPT_NAME -x ok0 uptime                Exclude ok0 from this run
  $SCRIPT_NAME -- list /tmp                 Run 'list /tmp' (not subcommand)
  $SCRIPT_NAME list -R                      List hosts with connectivity check

EOT
}

# ------------------------------------------------------------------------------
# install_symlinks() - Create/manage symlinks in /usr/local/bin
# Creates symlinks for all aliases defined in hosts.conf, pointing to ok_master.
# Options: -n/--dry-run, --remove-stale, --clean-local
# Returns: 0 on success, 22 on invalid option
# ------------------------------------------------------------------------------
install_symlinks() {
  local -i dry_run=0 remove_stale=0 clean_local=0
  local -- target_dir=/usr/local/bin
  local -i created=0 updated=0 skipped=0 removed=0

  # Locate ok_master: prefer installed location, fall back to dev directory
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      --remove-stale) remove_stale=1 ;;
      --clean-local) clean_local=1 ;;
      -h|--help)
          cat <<-EOT
	Usage: $SCRIPT_NAME install [OPTIONS]

	Create symlinks in /usr/local/bin for all hosts.conf aliases.
	Symlinks point to ok_master for server resolution.

	Options:
	  -n, --dry-run      Preview changes (no modifications)
	  --remove-stale     Remove symlinks not in hosts.conf
	  --clean-local      Remove symlinks from script directory
	  -h, --help         Show this help

	Examples:
	  $SCRIPT_NAME install                  Create/update all symlinks
	  $SCRIPT_NAME install --dry-run        Preview what would change
	  $SCRIPT_NAME install --remove-stale   Clean up old symlinks
	EOT
        return 0
        ;;
      *)
        error "Unknown install option ${1@Q}"
        return 22
        ;;
    esac
    shift
  done

  # Load hosts.conf (auto-detects /etc/oknav/ or script directory)
  #shellcheck disable=SC2119
  load_hosts_conf

  # Check for aliases that conflict with subcommand names
  local -a reserved_names=(install add remove list help)
  local -- alias_name reserved
  for alias_name in "${ALIAS_LIST[@]}"; do
    for reserved in "${reserved_names[@]}"; do
      if [[ "$alias_name" == "$reserved" ]]; then
        warn "alias ${alias_name@Q} conflicts with oknav subcommand"
        warn "  use 'oknav -- $alias_name <cmd>' to execute on this server"
      fi
    done
  done

  info "Installing symlinks to $target_dir"
  ((dry_run)) && info "[dry-run] No changes will be made"

  # Create symlinks for all aliases in hosts.conf
  local -- alias target
  for alias in "${ALIAS_LIST[@]}"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        ((++skipped))
      else
        info "  update: $alias (was → $(readlink "$target"))"
        ((dry_run)) || ln -sf "$ok_master" "$target"
        ((++updated))
      fi
    elif [[ -e "$target" ]]; then
      warn "  $alias: file exists (not a symlink) - skipping"
    else
      info "  create: $alias"
      ((dry_run)) || ln -sf "$ok_master" "$target"
      ((++created))
    fi
  done

  # Remove stale symlinks (pointing to ok_master but not in hosts.conf)
  if ((remove_stale)); then
    local -- link name
    for link in "$target_dir"/ok*; do
      [[ -L "$link" ]] || continue
      [[ "$(readlink "$link")" == "$ok_master" ]] || continue
      name="${link##*/}"
      [[ -n "${ALIAS_TO_FQDN[$name]:-}" ]] && continue
      info "  remove: $name (stale)"
      ((dry_run)) || rm -f "$link"
      ((++removed))
    done
  fi

  # Clean local symlinks
  if ((clean_local)); then
    local -- link name
    for link in "$SCRIPT_DIR"/ok*; do
      [[ -L "$link" ]] || continue
      name="${link##*/}"
      info "  remove: $name (local)"
      ((dry_run)) || rm -f "$link"
      ((++removed))
    done
  fi

  echo
  success "Done: $created created, $updated updated, $skipped unchanged, $removed removed"
  return 0
}

# ------------------------------------------------------------------------------
# add_host() - Create ad-hoc host launcher symlinks
# Creates symlinks in /usr/local/bin → ok_master for quick SSH access.
# Hostname must be resolvable via DNS/hosts. Requires sudo.
# Args: [-n] <hostname> [alias...]
# Returns: 0 success, 1 error (unresolvable host), 22 invalid option
# ------------------------------------------------------------------------------
add_host() {
  local -i dry_run=0
  local -- target_dir=/usr/local/bin

  # Locate ok_master: prefer installed location, fall back to dev directory
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      -h|--help)
        cat <<-'EOT'
	Usage: oknav add [-n] <hostname> [alias...]

	Create ad-hoc launcher symlinks for quick SSH access (requires sudo).
	Hostname must be resolvable via DNS or /etc/hosts.

	Arguments:
	  hostname    FQDN or IP address (must be resolvable)
	  alias...    Symlink names (defaults to hostname if omitted)

	Options:
	  -n, --dry-run   Preview changes (no modifications)
	  -h, --help      Show this help

	Examples:
	  oknav add server.example.com              Create launcher 'server.example.com'
	  oknav add server.example.com srv server   Create launchers 'srv' and 'server'

	Note: Ad-hoc hosts are NOT included in cluster operations.
	      Use hosts.conf with (oknav) option for cluster membership.
	EOT
        return 0 ;;
      -*) error "Unknown option ${1@Q}"; return 22 ;;
      *) break ;;
    esac
    shift
  done

  # Require hostname
  (($#)) || { error "Usage: oknav add [-n] <hostname> [alias...]"; return 1; }

  local -- hostname=$1; shift

  # Validate hostname is resolvable
  if ! getent hosts "$hostname" &>/dev/null; then
    error "Cannot resolve hostname: $hostname"
    return 1
  fi

  # Use hostname as alias if none provided
  local -a aliases=("${@:-$hostname}")

  ((dry_run)) && info "[dry-run] No changes will be made"

  # Create symlinks (requires sudo for /usr/local/bin)
  local -- alias target reply
  for alias in "${aliases[@]}"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        info "  skip: $alias (already exists)"
      else
        # Symlink exists but points elsewhere
        if [[ -t 0 && -t 1 ]]; then
          # Interactive: prompt user
          read -rp "oknav: $alias exists (→ $(readlink "$target")). Overwrite? [y/N] " reply
          [[ "$reply" =~ ^[Yy] ]] || { info "  skip: $alias"; continue; }
        fi
        info "  update: $alias (was: $(readlink "$target"))"
        ((dry_run)) || sudo ln -sf "$ok_master" "$target"
      fi
    elif [[ -e "$target" ]]; then
      warn "  $alias: file exists (not a symlink) - skipping"
    else
      info "  create: $alias → $hostname"
      ((dry_run)) || sudo ln -sf "$ok_master" "$target"
    fi
  done
}

# ------------------------------------------------------------------------------
# remove_host() - Remove ad-hoc host launcher symlinks
# Removes symlinks from /usr/local/bin that point to ok_master. Requires sudo.
# Only removes symlinks pointing to ok_master; ignores other files.
# Args: [-n] <alias>...
# Returns: 0 always (warnings for non-existent/non-symlink files)
# ------------------------------------------------------------------------------
remove_host() {
  local -i dry_run=0
  local -- target_dir=/usr/local/bin

  # Locate ok_master for symlink validation
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  while (($#)); do
    case $1 in
      -n|--dry-run) dry_run=1 ;;
      -h|--help)
        cat <<-'EOT'
	Usage: oknav remove [-n] <alias>...

	Remove launcher symlinks (requires sudo).
	Only removes symlinks that point to ok_master.

	Arguments:
	  alias...    Symlink names to remove

	Options:
	  -n, --dry-run   Preview changes (no modifications)
	  -h, --help      Show this help

	Examples:
	  oknav remove srv                  Remove single launcher
	  oknav remove srv server backup    Remove multiple launchers
	EOT
        return 0 ;;
      -*) error "Unknown option ${1@Q}"; return 22 ;;
      *) break ;;
    esac
    shift
  done

  # Require at least one alias
  (($#)) || { error 'Usage: oknav remove [-n] <alias>...'; return 1; }

  ((dry_run)) && info '[dry-run] No changes will be made'

  # Remove symlinks (requires sudo for /usr/local/bin)
  local -- alias target
  for alias in "$@"; do
    target="$target_dir/$alias"
    if [[ -L "$target" ]]; then
      if [[ "$(readlink "$target")" == "$ok_master" ]]; then
        info "  remove: $alias"
        ((dry_run)) || sudo rm -f "$target"
      else
        warn "  $alias: symlink points elsewhere - skipping"
      fi
    elif [[ -e "$target" ]]; then
      warn "  $alias: not a symlink - skipping"
    else
      warn "  $alias: not found"
    fi
  done
}

# ------------------------------------------------------------------------------
# list_hosts() - List all host symlinks pointing to ok_master
# Shows which hosts are defined in hosts.conf vs ad-hoc additions.
# Args: [-R|--reachable] [-p|--parallel] [-h|--help]
# Returns: 0 always
# ------------------------------------------------------------------------------
list_hosts() {
  local -- target_dir=${OKNAV_TARGET_DIR:-/usr/local/bin}
  local -i reachable_check=0
  local -i parallel_mode=0

  # Locate ok_master: prefer installed location, fall back to dev directory
  local -- ok_master=/usr/local/share/oknav/ok_master
  [[ -f "$ok_master" ]] || ok_master="$SCRIPT_DIR"/ok_master

  # Parse options
  while (($#)); do
    case $1 in
      -R|--reachable)
        reachable_check=1 ;;
      -p|--parallel)
        parallel_mode=1 ;;
      -h|--help)
        cat <<-'EOT'
	Usage: oknav list [-R] [-p]

	List all host launcher symlinks pointing to ok_master.
	Shows source (hosts.conf or ad-hoc) for each host.

	Options:
	  -R, --reachable  Test SSH connectivity (5s timeout per host)
	  -p, --parallel   Test hosts in parallel (use with -R)
	  -h, --help       Show this help

	Output Columns:
	  NAME    Symlink name (launcher command)
	  SOURCE  hosts.conf or ad-hoc
	  STATUS  ✓ reachable, ✗ unreachable (with -R only)

	Examples:
	  oknav list                List all launchers
	  oknav list -R             List with connectivity status
	  oknav list -Rp            Parallel connectivity check
	EOT
        return 0 ;;
      *)
        warn "Unknown option: $1"
        return 22 ;;
    esac
    shift
  done

  # Load hosts.conf for status checking
  #shellcheck disable=SC2119
  load_hosts_conf

  # Find symlinks pointing to ok_master (match by target basename)
  local -a aliases=()
  local -- link name target

  while IFS= read -r link; do
    [[ -L "$link" ]] || continue
    target=$(readlink "$link")
    # Check if symlink target ends with ok_master
    [[ "${target##*/}" == ok_master ]] || continue
    name="${link##*/}"
    [[ "$name" == ok_master ]] && continue
    aliases+=("$name")
  done < <(find "$target_dir" -maxdepth 1 -type l 2>/dev/null | sort)

  # Build host info array (name:source:fqdn)
  local -a host_info=()
  local -- fqdn source
  for name in "${aliases[@]}"; do
    if [[ -n "${ALIAS_TO_FQDN[$name]:-}" ]]; then
      fqdn="${ALIAS_TO_FQDN[$name]}"
      source=hosts.conf
    else
      fqdn="$name"
      source=ad-hoc
    fi
    host_info+=("$name:$source:$fqdn")
  done

  # Display with status
  if ((reachable_check)); then
    if ((parallel_mode)); then
      # Parallel reachability check
      local -a pids=() temp_files=()
      local -- temp_file

      for info in "${host_info[@]}"; do
        name="${info%%:*}"
        temp_file=$(mktemp "$TEMP_DIR"/oknav_list_"$name"_XXXXXX) || continue
        temp_files+=("$temp_file")

        # Background SSH test
        (
          fqdn="${info##*:}"
          if timeout 5 ssh -o ConnectTimeout=3 -o BatchMode=yes "$fqdn" hostname >/dev/null 2>&1; then
            echo '✓'
          else
            echo '✗'
          fi
        ) > "$temp_file" 2>/dev/null &
        pids+=($!)
      done

      # Wait for all background processes
      for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null || true
      done

      # Display results in order
      local -i i=0
      local -- status
      for info in "${host_info[@]}"; do
        name="${info%%:*}"
        source="${info#*:}"
        source="${source%%:*}"
        status=$(<"${temp_files[$i]}") || status='✗'
        printf '%-12s %-10s  %s\n' "$name" "$source" "$status"
        ((++i))
      done

      # Cleanup temp files
      rm -f "${temp_files[@]}" 2>/dev/null || true
    else
      # Sequential reachability check
      local -- status
      for info in "${host_info[@]}"; do
        name="${info%%:*}"
        source="${info#*:}"
        source="${source%%:*}"
        fqdn="${info##*:}"
        if timeout 5 ssh -o ConnectTimeout=3 -o BatchMode=yes "$fqdn" hostname >/dev/null 2>&1; then
          status='✓'
        else
          status='✗'
        fi
        printf '%-12s %-10s  %s\n' "$name" "$source" "$status"
      done
    fi
  else
    # No reachability check - just list
    for info in "${host_info[@]}"; do
      name="${info%%:*}"
      source="${info#*:}"
      source="${source%%:*}"
      printf '%-12s %s\n' "$name" "$source"
    done
  fi
}

# Parse command line arguments
while (($#)); do
  case $1 in
    -x|--exclude-host)
      shift
      ok_server_excludes+=("$1");;
    -p|--parallel|parallel)
      PARALLEL=1 ;;
    -t|--timeout)
      shift
      TIMEOUT=${1:-30}  # Use provided timeout or keep default
      [[ "$TIMEOUT" =~ ^[0-9]+$ ]] || die 22 "Invalid timeout value ${TIMEOUT@Q}" ;;
    -D|--debug)
      DEBUG=1 ;;
    -V|--version)
      echo "$SCRIPT_NAME $VERSION"
      exit 0 ;;
    -h|--help|help)
      usage
      exit 0;;
    -[xptDVh]*)
      # Handle combined short options (e.g., -pD becomes -p -D)
      #shellcheck disable=SC2046
      set -- '' $(printf -- '-%c ' $(grep -o . <<<"${1:1}")) "${@:2}" ;;
    --)
      # End of options, force multi-execute mode (bypass subcommand check)
      FORCE_EXEC=1
      shift
      break ;;
    -*)
      die 22 "Invalid option ${1@Q}" ;;
    *)
      # First non-option argument starts the command
      break ;;
  esac
  shift
done

# Handle subcommands (skip if -- was used to force multi-execute)
if ((! FORCE_EXEC)); then
  case ${1:-} in
    install)
      shift
      install_symlinks "$@"
      exit $?
      ;;
    add)
      shift
      add_host "$@"
      exit $?
      ;;
    remove)
      shift
      remove_host "$@"
      exit $?
      ;;
    list)
      shift
      list_hosts "$@"
      exit $?
      ;;
  esac
fi

# If no command provided, show usage
(($#)) || { >&2 usage; exit 1; }

# Load hosts.conf configuration (auto-detects /etc/oknav/ or script directory)
#shellcheck disable=SC2119
load_hosts_conf

# Discover servers from hosts.conf with (oknav) option
# Apply exclusions from:
# 1. Command-line -x options (already in ok_server_excludes)
# 2. hosts.conf (exclude) options
# 3. hosts.conf (local-only) constraints

declare -a SERVERS=()
declare -- alias required_host

for alias in "${ALIAS_LIST[@]}"; do
  # Only include aliases marked with (oknav)
  is_oknav "$alias" || continue

  # Check for (exclude) option
  is_excluded "$alias" && continue

  # Check for (local-only) constraint violation
  required_host=$(get_local_only_host "$alias")
  if [[ -n "$required_host" && "$HOSTNAME" != "$required_host" ]]; then
    continue
  fi

  # Check command-line exclusions (-x options)
  if ((${#ok_server_excludes[@]})); then
    printf '%s\n' "${ok_server_excludes[@]}" | grep -Fxq "$alias" && continue
  fi

  SERVERS+=("$alias")
done

# Validate server discovery
if ((${#SERVERS[@]} == 0)); then
  error 'No cluster servers found'
  echo >&2
  # Check if command looks like a typo of a subcommand
  if [[ -n "${1:-}" ]]; then
    case "$1" in
      instal|instll|inst|nstall)
        info "Did you mean: oknav install"
        info "  (typo detected: ${1@Q})" ;;
      lst|lis|lsit|lits)
        info "Did you mean: oknav list"
        info "  (typo detected: ${1@Q})" ;;
      ad|adds|dad|aad)
        info "Did you mean: oknav add <hostname>"
        info "  (typo detected: ${1@Q})" ;;
      remov|rm|del|delete|rmove|reomve)
        info "Did you mean: oknav remove <alias>"
        info "  (typo detected: ${1@Q})" ;;
      *)
        info "To run ${1@Q} on cluster servers, ensure hosts.conf has" \
             "entries with (oknav) option"
        ;;
    esac
  else
    info 'Ensure hosts.conf has entries with (oknav) option'
  fi
  echo >&2
  info 'Check server discovery with: oknav -D hostname'
  info 'List available hosts with:   oknav list'
  exit 1
fi

# Debug output for server discovery
if ((DEBUG)); then
  >&2 echo "DEBUG: Cluster execution:"
  >&2 echo "  SERVERS = ${SERVERS[*]}"
  >&2 echo "  COMMAND = $*"
  >&2 echo "  MODE    = $( ((PARALLEL)) && echo 'parallel' || echo 'sequential')"
  >&2 echo "  TIMEOUT = ${TIMEOUT}s"
  ((${#ok_server_excludes[@]})) && >&2 echo "  EXCLUDE = ${ok_server_excludes[*]}"
  >&2 echo
fi

# ------------------------------------------------------------------------------
# run_command() - Execute command on single server (parallel mode helper)
# Captures output to temp file for ordered display after all complete.
# Args: server command [args...]
# Returns: 0 success, 1 temp file creation failed
# Timeout exit codes: 124=timeout, 125=timeout error, 126=command not found
# ------------------------------------------------------------------------------
run_command() {
  local -- server=$1
  local -- temp_file
  shift

  temp_file=$(mktemp "$TEMP_DIR"/"$SCRIPT_NAME"_"$server"_XXXXXX) || {
    error "Cannot create temporary file for ${server@Q}"
    return 1
  }
  TEMP_FILES+=("$temp_file")

  # Capture all output (stdout + stderr) to temp file
  { echo "+++$server:"
    timeout "$TIMEOUT"s sudo "$server" "$@" || {
      exit_code=$?
      case $exit_code in
        124) echo "Connection timeout after $TIMEOUT seconds" ;;
        125) echo 'Timeout command error' ;;
        126) echo "Command not found: $server" ;;
      esac
      true  # Continue regardless of error
    }
    echo
  } &> "$temp_file"

  # Write reference file for output collection phase
  echo "$temp_file" > "$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile
  TEMP_FILES+=("$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile)
}

# ==============================================================================
# Main Execution
# ==============================================================================
declare -i first=0

if (( PARALLEL )); then
  # --------------------------------------------------------------------------
  # PARALLEL MODE: All servers execute simultaneously, output collected after
  # --------------------------------------------------------------------------
  declare -a pids=()

  for server in "${SERVERS[@]}"; do
    run_command "$server" "$@" &
    pids+=($!)
  done

  # Wait for all background processes
  for pid in "${pids[@]}"; do
    wait "$pid" || true
  done

  # Display outputs in server order (not completion order)
  for server in "${SERVERS[@]}"; do
    temp_file_path="$TEMP_DIR"/."$SCRIPT_NAME"_"$server"_tempfile
    if [[ -f "$temp_file_path" ]]; then
      temp_file=$(<"$temp_file_path")
      if [[ -f "$temp_file" ]]; then
        ((first)) && echo || first=1
        cat "$temp_file"
      else
        warn "Output file for ${server@Q} not found"
      fi
      rm -f "$temp_file_path"
    fi
  done
else
  # --------------------------------------------------------------------------
  # SEQUENTIAL MODE: Execute on each server in order, display immediately
  # --------------------------------------------------------------------------
  for server in "${SERVERS[@]}"; do
    ((first)) && echo || first=1
    echo "+++$server:"
    timeout "$TIMEOUT"s sudo "$server" "$@" || {
      exit_code=$?
      case $exit_code in
        124) echo "Connection timeout after $TIMEOUT seconds" ;;
        125) echo 'Timeout command error' ;;
        126) echo "Command not found ${server@Q}" ;;
      esac
      true  # Continue regardless of error
    }
    echo
  done
fi

debug "Execution completed for ${#SERVERS[@]} servers"

# vim: set ts=2 sw=2 et:
#fin
